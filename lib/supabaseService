import { supabase } from "./supabaseClient";
import { productStore } from "./productStore";
import { StorageService } from "./storageService";
import type { Product, User, SiteAnalytics } from "./types";
 
// Product Services
export const productService = {
  // Get all products
  async getProducts(): Promise<Product[]> {
    return productStore.getProducts();
  },

  // Get product by ID
  async getProduct(id: string): Promise<Product | null> {
    return productStore.getProduct(id);
  },

  // Add new product with enhanced error handling
  async addProduct(product: Omit<Product, "id">): Promise<string | null> {
    try {
      console.log("üîÑ Adding product:", product.name);

      // Validate required fields
      if (!product.name?.trim()) {
        throw new Error("Product name is required");
      }
      if (!product.description?.trim()) {
        throw new Error("Product description is required");
      }
      if (!product.price || product.price <= 0) {
        throw new Error("Valid price is required");
      }
      if (!product.affiliate_link?.trim()) {
        throw new Error("Affiliate link is required");
      }

      // Ensure image URL exists
      if (!product.image_url) {
        product.image_url = `/placeholder.svg?height=400&width=400&text=${encodeURIComponent(product.name)}`;
      }

      // Try Supabase first
      try {
        const { data, error } = await supabase
          .from('products')
          .insert({
            ...product,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
          })
          .select();

        if (error) throw error;

        if (data && data[0]) {
          // Also add to local store for immediate display
          productStore.addProduct(data[0]);
          console.log("‚úÖ Product added to both Supabase and local store");
          return data[0].id;
        }
      } catch (error) {
        console.error("Supabase add failed, using local store:", error);
      }

      // Fallback to local store
      const localId = productStore.addProduct(product);
      console.log("‚úÖ Product added to local store (demo mode)");
      return localId;
    } catch (error) {
      console.error("‚ùå Error adding product:", error);
      throw error; // Re-throw to be handled by the UI
    }
  },

  // Update product
  async updateProduct(id: string, updates: Partial<Product>): Promise<boolean> {
    try {
      // Try Supabase first
      try {
        const { error } = await supabase
          .from('products')
          .update({
            ...updates,
            updated_at: new Date().toISOString(),
          })
          .eq('id', id);

        if (error) throw error;

        // Also update local store
        productStore.updateProduct(id, updates);
        console.log("‚úÖ Product updated in both Supabase and local store");
        return true;
      } catch (error) {
        console.error("Supabase update failed, using local store:", error);
      }

      // Fallback to local store
      const success = productStore.updateProduct(id, updates);
      console.log("‚úÖ Product updated in local store (demo mode)");
      return success;
    } catch (error) {
      console.error("‚ùå Error updating product:", error);
      return false;
    }
  },

  // Delete product
  async deleteProduct(id: string): Promise<boolean> {
    try {
      // Try Supabase first
      try {
        const { error } = await supabase
          .from('products')
          .delete()
          .eq('id', id);

        if (error) throw error;

        // Also delete from local store
        productStore.deleteProduct(id);
        console.log("‚úÖ Product deleted from both Supabase and local store");
        return true;
      } catch (error) {
        console.error("Supabase delete failed, using local store:", error);
      }

      // Fallback to local store
      const success = productStore.deleteProduct(id);
      console.log("‚úÖ Product deleted from local store (demo mode)");
      return success;
    } catch (error) {
      console.error("‚ùå Error deleting product:", error);
      return false;
    }
  },

  // Increment product clicks
  async incrementClicks(id: string): Promise<boolean> {
    // Always update local store for immediate feedback
    const success = productStore.incrementClicks(id);

    // Try Supabase in background
    try {
      // First get current clicks value
      const { data: productData, error: fetchError } = await supabase
        .from('products')
        .select('clicks')
        .eq('id', id)
        .single();

      if (fetchError) throw fetchError;

      const currentClicks = productData?.clicks || 0;

      const { error } = await supabase
        .from('products')
        .update({
          clicks: currentClicks + 1,
          updated_at: new Date().toISOString(),
        })
        .eq('id', id);

      if (error) throw error;

      console.log("‚úÖ Click count updated in Supabase");
    } catch (error) {
      console.error("Supabase click update failed (local store still updated):", error);
    }

    return success;
  },

  // Subscribe to product changes
  subscribe(callback: (products: Product[]) => void): () => void {
    return productStore.subscribe(callback);
  },

  // Get product statistics
  getStats() {
    return productStore.getStats();
  },
};

// User Services
export const userService = {
  // Get user by email
  async getUserByEmail(email: string): Promise<User | null> {
    try {
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .eq('email', email)
        .maybeSingle();

      if (error) throw error;

      // Check for the admin email as fallback
      if (!data && email === "akk116636@gmail.com") {
        return {
          id: "admin-1",
          email: "akk116636@gmail.com",
          role: "admin",
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        };
      }

      return data;
    } catch (error) {
      console.error("Error fetching user:", error);
      return null;
    }
  },

  // Add new user
  async addUser(user: Omit<User, "id">): Promise<string | null> {
    try {
      const { data, error } = await supabase
        .from('users')
        .insert({
          ...user,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        })
        .select()
        .single();

      if (error) throw error;

      return data.id;
    } catch (error) {
      console.error("Error adding user:", error);
      return null;
    }
  },

  // Get all users
  async getUsers(): Promise<User[]> {
    try {
      const { data, error } = await supabase
        .from('users')
        .select('*');

      if (error) throw error;

      // Include admin user if not present
      const adminExists = data?.some(user => user.email === "akk116636@gmail.com");
      if (!adminExists) {
        return [
          ...(data || []),
          {
            id: "admin-1",
            email: "akk116636@gmail.com",
            role: "admin",
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
          },
        ];
      }

      return data || [];
    } catch (error) {
      console.error("Error fetching users:", error);
      return [];
    }
  },
};

// Analytics Services
export const analyticsService = {
  // Track product click
  async trackClick(productId: string, userIp: string, userAgent: string): Promise<boolean> {
    try {
      // First get the current analytics record for today
      const today = new Date().toISOString().split('T')[0];
      const { data: existingData, error: fetchError } = await supabase
        .from('analytics')
        .select('*')
        .eq('date', today)
        .maybeSingle();

      let totalClicks = 1;
      let totalVisitors = 1;

      if (existingData) {
        totalClicks = existingData.total_clicks + 1;
        totalVisitors = existingData.total_visitors;
        
        // Check if this is a new visitor (simplified)
        const { error: updateError } = await supabase
          .from('analytics')
          .update({
            total_clicks: totalClicks,
            updated_at: new Date().toISOString(),
          })
          .eq('id', existingData.id);

        if (updateError) throw updateError;
      } else {
        const { error: insertError } = await supabase
          .from('analytics')
          .insert({
            date: today,
            total_visitors: 1,
            total_clicks: 1,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
          });

        if (insertError) throw insertError;
      }

      // Also track the click event
      const { error: clickError } = await supabase
        .from('click_events')
        .insert({
          product_id: productId,
          user_ip: userIp,
          user_agent: userAgent,
          created_at: new Date().toISOString(),
        });

      if (clickError) throw clickError;

      return true;
    } catch (error) {
      console.error("Error tracking click:", error);
      return false;
    }
  },

  // Get site analytics
  async getSiteAnalytics(): Promise<SiteAnalytics | null> {
    try {
      const today = new Date().toISOString().split('T')[0];
      const { data, error } = await supabase
        .from('analytics')
        .select('*')
        .eq('date', today)
        .maybeSingle();

      if (error) throw error;

      if (data) {
        return data;
      }

      // Return default stats if no record exists
      const stats = productStore.getStats();
      return {
        id: "default",
        date: today,
        total_visitors: 0,
        total_clicks: stats.totalClicks,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };
    } catch (error) {
      console.error("Error fetching analytics:", error);
      return null;
    }
  },

  // Update site analytics
  async updateSiteAnalytics(totalVisitors: number, totalClicks: number): Promise<boolean> {
    try {
      const today = new Date().toISOString().split('T')[0];
      
      // First check if record exists
      const { data: existingData, error: fetchError } = await supabase
        .from('analytics')
        .select('id')
        .eq('date', today)
        .maybeSingle();

      if (fetchError) throw fetchError;

      if (existingData) {
        // Update existing record
        const { error: updateError } = await supabase
          .from('analytics')
          .update({
            total_visitors: totalVisitors,
            total_clicks: totalClicks,
            updated_at: new Date().toISOString(),
          })
          .eq('id', existingData.id);

        if (updateError) throw updateError;
      } else {
        // Create new record
        const { error: insertError } = await supabase
          .from('analytics')
          .insert({
            date: today,
            total_visitors: totalVisitors,
            total_clicks: totalClicks,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
          });

        if (insertError) throw insertError;
      }

      return true;
    } catch (error) {
      console.error("Error updating analytics:", error);
      return false;
    }
  },
};

// Enhanced Storage Services
export const storageService = {
  // Upload product image with multiple strategies
  uploadProductImage: StorageService.uploadProductImage,

  // Delete image
  deleteImage: StorageService.deleteImage,

  // Validate image file
  validateImageFile: StorageService.validateImageFile,

  // Compress image
  compressImage: StorageService.compressImage,
};

// Real-time listeners
export const realtimeService = {
  // Listen to products changes
  onProductsChange(callback: (products: Product[]) => void) {
    // Use the product store subscription
    const storeUnsubscribe = productStore.subscribe(callback);

    // Set up Supabase realtime subscription
    const subscription = supabase
      .channel('products-changes')
      .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'products' },
        async () => {
          // Refresh products when changes occur
          await productStore.loadProducts();
        }
      )
      .subscribe();

    // Return combined unsubscribe function
    return () => {
      storeUnsubscribe();
      supabase.removeChannel(subscription);
    };
  },

  // Listen to analytics changes
  onAnalyticsChange(callback: (analytics: SiteAnalytics | null) => void) {
    // First call with current data
    analyticsService.getSiteAnalytics().then(callback);

    // Set up Supabase realtime subscription
    const subscription = supabase
      .channel('analytics-changes')
      .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'analytics' },
        async () => {
          const analytics = await analyticsService.getSiteAnalytics();
          callback(analytics);
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(subscription);
    };
  },
};
